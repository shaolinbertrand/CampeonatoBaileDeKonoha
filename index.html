<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneio: O Melhor Shinobi do Baile de Konoha</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Torneio: O Melhor Shinobi do Baile de Konoha</h1>

    <div class="container">
        <div class="input-section">
            <h2>Adicionar Shinobi</h2>
            <input type="text" id="playerNameInput" placeholder="Nome do Shinobi">
            <button id="addPlayerBtn">Adicionar</button>
        </div>

        <div class="player-list-section">
            <h2>Shinobis Inscritos (<span id="playerCount">0</span>)</h2>
            <div id="playerList">
                </div>
            <button id="startTournamentBtn">Iniciar Torneio</button>
            <p style="font-size: 0.9em; color: #666;">*Mínimo de 4 jogadores para iniciar o torneio.</p>
        </div>

        <div class="tournament-bracket-section">
            <h2>Chave do Torneio</h2>
            <div id="tournamentBracket" class="tournament-bracket">
                </div>
        </div>
    </div>

    <script>
        const playerNameInput = document.getElementById('playerNameInput');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const playerListDiv = document.getElementById('playerList');
        const playerCountSpan = document.getElementById('playerCount');
        const startTournamentBtn = document.getElementById('startTournamentBtn');
        const tournamentBracketDiv = document.getElementById('tournamentBracket');

        let players = [];
        let currentRound = 0; // Controla a rodada atual
        let matches = []; // Armazena as partidas de cada rodada

        // Função para atualizar a lista de jogadores na tela
        function updatePlayerList() {
            playerListDiv.innerHTML = ''; // Limpa a lista atual
            players.forEach((player, index) => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.innerHTML = `
                    <span>${player}</span>
                    <button data-index="${index}">Remover</button>
                `;
                playerListDiv.appendChild(playerItem);
            });
            playerCountSpan.textContent = players.length;
            updateStartButtonState();
        }

        // Adicionar jogador
        addPlayerBtn.addEventListener('click', () => {
            const playerName = playerNameInput.value.trim();
            if (playerName && !players.includes(playerName)) { // Evita nomes duplicados
                players.push(playerName);
                playerNameInput.value = '';
                updatePlayerList();
            } else if (players.includes(playerName)) {
                alert('Este Shinobi já foi adicionado!');
            }
        });

        // Remover jogador (usando delegação de eventos para botões dinâmicos)
        playerListDiv.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const indexToRemove = parseInt(event.target.dataset.index);
                players.splice(indexToRemove, 1);
                updatePlayerList();
            }
        });

        // Habilita/desabilita o botão de iniciar torneio
        function updateStartButtonState() {
            startTournamentBtn.disabled = players.length < 4; // Mínimo de 4 jogadores
        }

        // Função para embaralhar os jogadores (Fisher-Yates shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Função para criar as chaves da primeira rodada
        function createFirstRoundMatches() {
            let shuffledPlayers = shuffleArray([...players]); // Cópia embaralhada
            matches = []; // Limpa partidas anteriores

            if (shuffledPlayers.length % 2 !== 0) {
                alert("Número ímpar de jogadores. Um jogador terá um 'bye' ou a chave pode ficar desbalanceada.");
            }

            let roundMatches = [];
            for (let i = 0; i < shuffledPlayers.length; i += 2) {
                const player1 = shuffledPlayers[i];
                const player2 = shuffledPlayers[i + 1] || 'BYE'; // Se for ímpar, o último terá um BYE
                roundMatches.push({
                    player1: player1,
                    player2: player2,
                    winner: null,
                    matchId: `R0M${roundMatches.length}` // ID da partida
                });
            }
            matches.push(roundMatches); // Adiciona a primeira rodada
            currentRound = 0;
            renderTournamentBracket();
        }

        // Função para gerar a próxima rodada
        function generateNextRound() {
            const previousRoundMatches = matches[currentRound];
            const winners = previousRoundMatches
                .filter(match => match.winner !== null && match.winner !== 'BYE')
                .map(match => match.winner);

            if (winners.length <= 1) { // Torneio finalizado ou apenas um vencedor
                if (winners.length === 1) {
                    alert(`O grande vencedor do torneio é: ${winners[0]}! Parabéns!`);
                } else {
                    alert('Nenhum vencedor para a próxima rodada. Verifique as partidas anteriores.');
                }
                startTournamentBtn.disabled = true; // Desabilita o botão de iniciar após o fim
                return;
            }

            if (winners.length % 2 !== 0) {
                 alert("Número ímpar de vencedores para a próxima rodada. Um jogador terá um 'bye'.");
            }

            let nextRoundMatches = [];
            // Embaralha os vencedores para novas combinações
            let shuffledWinners = shuffleArray(winners);
            for (let i = 0; i < shuffledWinners.length; i += 2) {
                const player1 = shuffledWinners[i];
                const player2 = shuffledWinners[i + 1] || 'BYE';
                nextRoundMatches.push({
                    player1: player1,
                    player2: player2,
                    winner: null,
                    matchId: `R${currentRound + 1}M${nextRoundMatches.length}`
                });
            }
            matches.push(nextRoundMatches);
            currentRound++;
            renderTournamentBracket();
        }

        // Função para renderizar as chaves do torneio
        function renderTournamentBracket() {
            tournamentBracketDiv.innerHTML = ''; // Limpa as chaves atuais

            // Array de classes para as imagens 'versus'
            const versusClasses = ['vs1', 'vs2', 'vs3'];

            matches.forEach((roundMatches, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'round';
                roundDiv.innerHTML = `<h3>Rodada ${roundIndex + 1}</h3>`;

                roundMatches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match';
                    matchDiv.dataset.matchId = match.matchId;

                    // Escolhe uma classe 'versus' aleatoriamente e adiciona
                    const randomVersusClass = versusClasses[Math.floor(Math.random() * versusClasses.length)];
                    matchDiv.classList.add(randomVersusClass);

                    if (match.winner) {
                        matchDiv.classList.add('completed');
                    }

                    let optionsHtml = `<option value="">Selecione o vencedor</option>`;
                    if (match.player1 !== 'BYE') optionsHtml += `<option value="${match.player1}">${match.player1}</option>`;
                    if (match.player2 !== 'BYE') optionsHtml += `<option value="${match.player2}">${match.player2}</option>`;

                    matchDiv.innerHTML = `
                        <div class="player">${match.player1}</div>
                        <div class="player">${match.player2}</div>
                        ${match.winner ?
                            `<div class="winner-display">Vencedor: ${match.winner}</div>` :
                            `<select class="winner-select">
                                ${optionsHtml}
                            </select>
                            <button class="declare-winner">Declarar Vencedor</button>`
                        }
                    `;
                    roundDiv.appendChild(matchDiv);
                });
                tournamentBracketDiv.appendChild(roundDiv);
            });
        }

        // Iniciar torneio
        startTournamentBtn.addEventListener('click', () => {
            if (players.length >= 4) {
                if (confirm('Deseja realmente iniciar o torneio? Os jogadores não poderão ser mais alterados.')) {
                    playerNameInput.disabled = true;
                    addPlayerBtn.disabled = true;
                    startTournamentBtn.disabled = true;
                    playerListDiv.querySelectorAll('button').forEach(btn => btn.disabled = true); // Desabilita botões de remover
                    createFirstRoundMatches();
                }
            } else {
                alert('Você precisa de no mínimo 4 Shinobis para iniciar o torneio!');
            }
        });

        // Lidar com a declaração de vencedor (usando delegação de eventos)
        tournamentBracketDiv.addEventListener('click', (event) => {
            if (event.target.classList.contains('declare-winner')) {
                const matchDiv = event.target.closest('.match');
                const matchId = matchDiv.dataset.matchId;
                const winnerSelect = matchDiv.querySelector('.winner-select');
                const selectedWinner = winnerSelect.value;

                if (selectedWinner) {
                    let foundMatch = null;
                    let roundIndexToUpdate = -1;
                    let matchIndexToUpdate = -1;

                    for (let r = 0; r < matches.length; r++) {
                        for (let m = 0; m < matches[r].length; m++) {
                            if (matches[r][m].matchId === matchId) {
                                foundMatch = matches[r][m];
                                roundIndexToUpdate = r;
                                matchIndexToUpdate = m;
                                break;
                            }
                        }
                        if (foundMatch) break;
                    }

                    if (foundMatch) {
                        foundMatch.winner = selectedWinner;
                        matchDiv.classList.add('completed');
                        renderTournamentBracket(); // Renderiza novamente para mostrar o vencedor

                        const allCurrentRoundMatchesCompleted = matches[currentRound].every(match => match.winner !== null);

                        if (allCurrentRoundMatchesCompleted) {
                            setTimeout(() => {
                                alert(`Todos os jogos da Rodada ${currentRound + 1} foram concluídos! Gerando próxima rodada...`);
                                generateNextRound();
                            }, 500);
                        }
                    }
                } else {
                    alert('Por favor, selecione um vencedor antes de declarar.');
                }
            }
        });

        // Inicializa a lista de jogadores ao carregar
        updatePlayerList();

    </script>
</body>
</html>
